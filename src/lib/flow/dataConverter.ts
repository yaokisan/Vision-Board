// Êó¢Â≠ò„Éá„Éº„Çø„Åã„ÇâReact FlowÂΩ¢Âºè„Å∏„ÅÆÂ§âÊèõ„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
import { Company, Position, Layer, Business, Task, Executor } from '@/types'
import { Edge } from '@xyflow/react'
import { FlowNode, NodeType, EdgeType, OrganizationFlowData } from '@/types/flow'
import { supabase } from '@/lib/supabase/client'

export class FlowDataConverter {
  // „Ç≥„É≥„ÉÜ„ÉäË°®Á§∫Âà§ÂÆö„É°„ÇΩ„ÉÉ„ÉâÔºàbusiness_idÁµ±ÂêàÁâàÔºâ
  static shouldShowContainer(
    container: { business_id?: string | null; attribute?: string },
    currentTab: 'company' | string
  ): boolean {
    // ‰ºöÁ§æ„Çø„Éñ„Åß„ÅØÂÖ®„Å¶„ÅÆ„Ç≥„É≥„ÉÜ„Éä„ÇíË°®Á§∫
    if (currentTab === 'company') {
      return true
    }
    
    // business_idÁµ±ÂêàÂÆå‰∫Ü: business_id„ÅÆ„Åø‰ΩøÁî®
    const containerBusinessId = container.business_id
    
    // business_id„Åånull„Åæ„Åü„ÅØ'company'„ÅÆÂ†¥Âêà„ÅØ‰ºöÁ§æ„É¨„Éô„É´
    if (!containerBusinessId || containerBusinessId === 'company') {
      return currentTab === 'company'
    }
    
    // ‰∫ãÊ•≠„Çø„Éñ„Åß„ÅØ„ÄÅË©≤ÂΩì‰∫ãÊ•≠ID„ÅÆ„Ç≥„É≥„ÉÜ„Éä„ÅÆ„ÅøË°®Á§∫
    return containerBusinessId === currentTab
  }
  // „Éé„Éº„ÉâÂ§âÊèõ
  static convertToNodes(
    companies: Company[],
    positions: Position[],
    layers: Layer[],
    businesses: Business[],
    tasks: Task[],
    executors: Executor[]
  ): FlowNode[] {
    const nodes: FlowNode[] = []
    
    // ‰ºöÁ§æ„Éé„Éº„Éâ
    companies.forEach(company => {
      const ceo = positions.find(p => p.company_id === company.id && p.name === 'CEO')
      
      // „Éá„Éê„ÉÉ„Ç∞: ‰ºöÁ§æ„ÅÆ‰ΩçÁΩÆÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
      console.log('üè¢ COMPANY POSITION DATA:', {
        id: company.id,
        name: company.name,
        position_x: (company as any).position_x,
        position_y: (company as any).position_y,
        company
      })
      
      const savedX = (company as any).position_x
      const savedY = (company as any).position_y
      const defaultPosition = { x: 500, y: 50 }
      
      // ÊñáÂ≠óÂàó„ÅÆ"0"„ÇÇÊúâÂäπ„Å™‰ΩçÁΩÆ„Å®„Åó„Å¶Êâ±„ÅÜ
      const hasValidPosition = (savedX !== null && savedX !== undefined && savedY !== null && savedY !== undefined)
      const finalPosition = hasValidPosition
        ? { x: Number(savedX), y: Number(savedY) }
        : defaultPosition
      
      console.log('üè¢ FINAL POSITION:', company.name, finalPosition)
      
      nodes.push({
        id: `company-${company.id}`,
        type: NodeType.COMPANY,
        position: finalPosition,
        data: {
          entity: company,
          label: company.name,
          size: { width: 320, height: 120 },
          ceoName: ceo?.person_name,
          business_id: null // ‰ºöÁ§æ„Éé„Éº„Éâ„ÅØbusiness_id=null
        },
        draggable: true,
        selectable: true
      })
    })
    
    // CXO„É¨„Ç§„É§„Éº„Ç≥„É≥„ÉÜ„Éä - Ëá™ÂãïÁîüÊàê„ÇíÁÑ°ÂäπÂåñÔºà„ÉÄ„Éü„Éº„Éá„Éº„ÇøÂïèÈ°åÂõûÈÅøÔºâ
    // if (positions.some(p => p.name !== 'CEO')) {
    //   nodes.push({
    //     id: 'cxo-layer',
    //     type: NodeType.CXO_LAYER,
    //     position: { x: 200, y: 250 },
    //     data: {
    //       entity: { id: 'cxo-layer', name: 'CXO„É¨„Ç§„É§„Éº' },
    //       label: 'CXO„É¨„Ç§„É§„Éº',
    //       containerSize: { width: 800, height: 200 },
    //       business_id: null // CXO„É¨„Ç§„É§„Éº„ÅØ‰ºöÁ§æ„É¨„Éô„É´
    //     },
    //     draggable: true,
    //     selectable: true
    //   })
    // }
    
    // ÂΩπËÅ∑„Éé„Éº„ÉâÔºàCXOÔºâ- CXO„É¨„Ç§„É§„ÉºÂÜÖ„Å´ÈÖçÁΩÆ
    positions.forEach((position, index) => {
      if (position.name !== 'CEO') { // CEO„ÅØ‰ºöÁ§æ„Ç´„Éº„Éâ„Å´Áµ±Âêà
        nodes.push({
          id: `position-${position.id}`,
          type: NodeType.CXO,
          position: { 
            x: (position as any).position_x !== null && (position as any).position_x !== undefined 
              ? Number((position as any).position_x) 
              : (50 + index * 280), 
            y: (position as any).position_y !== null && (position as any).position_y !== undefined 
              ? Number((position as any).position_y) 
              : 50 
          },
          data: {
            entity: position,
            label: `${position.name}: ${position.person_name}`,
            size: { width: 224, height: 120 },
            business_id: (position as any).business_id || null // CXO„ÅØÈÄöÂ∏∏nullÔºà‰ºöÁ§æ„É¨„Éô„É´Ôºâ
          },
          parentNode: 'cxo-layer',
          extent: 'parent' as const,
          draggable: true,
          selectable: true
        })
      }
    })
    
    // ‰∫ãÊ•≠„ÉªÁµåÂñ∂„É¨„Ç§„É§„Éº„Ç≥„É≥„ÉÜ„Éä
    layers.forEach((layer, index) => {
      // „Éá„Éê„ÉÉ„Ç∞: „É¨„Ç§„É§„Éº„ÅÆ‰ΩçÁΩÆ„Éª„Çµ„Ç§„Ç∫ÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
      console.log('üìã LAYER POSITION & SIZE DATA:', {
        id: layer.id,
        name: layer.name,
        position_x: (layer as any).position_x,
        position_y: (layer as any).position_y,
        width: (layer as any).width,
        height: (layer as any).height,
        layer
      })
      
      const savedX = (layer as any).position_x
      const savedY = (layer as any).position_y
      const savedWidth = (layer as any).width
      const savedHeight = (layer as any).height
      const defaultPosition = { x: 100 + index * 600, y: 500 }
      const defaultSize = { width: 500, height: 600 }
      
      // ÊñáÂ≠óÂàó„ÅÆ"0"„ÇÇÊúâÂäπ„Å™‰ΩçÁΩÆ„Å®„Åó„Å¶Êâ±„ÅÜ
      const hasValidPosition = (savedX !== null && savedX !== undefined && savedY !== null && savedY !== undefined)
      const finalPosition = hasValidPosition
        ? { x: Number(savedX), y: Number(savedY) }
        : defaultPosition
      
      // „Çµ„Ç§„Ç∫ÊÉÖÂ†±„ÇÇÂêåÊßò„Å´Âá¶ÁêÜ
      const hasValidSize = (savedWidth !== null && savedWidth !== undefined && savedHeight !== null && savedHeight !== undefined)
      const finalSize = hasValidSize
        ? { width: Number(savedWidth), height: Number(savedHeight) }
        : defaultSize
      
      console.log('üìã FINAL LAYER POSITION & SIZE:', layer.name, finalPosition, finalSize)
      
      nodes.push({
        id: `layer-${layer.id}`,
        type: NodeType.BUSINESS_LAYER,
        position: finalPosition,
        data: {
          entity: layer,
          label: layer.name,
          type: layer.type as 'business' | 'management',
          containerSize: finalSize,
          business_id: (layer as any).business_id || null, // „É¨„Ç§„É§„Éº„ÅÆbusiness_id
          color: (layer as any).color || 'gray', // „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆcolor„Ç´„É©„É†„Çí‰ΩøÁî®
          description: (layer as any).description || '' // „Éá„Éº„Çø„Éô„Éº„Çπ„ÅÆdescription„Ç´„É©„É†„Çí‰ΩøÁî®
        },
        draggable: true,
        selectable: true
      })
    })
    
    // ‰∫ãÊ•≠„Éé„Éº„Éâ - Áã¨Á´ãÈÖçÁΩÆÔºà„É¨„Ç§„É§„Éº„Å´Â±û„Åï„Å™„ÅÑÔºâ
    businesses.forEach((business, index) => {
      nodes.push({
        id: `business-${business.id}`,
        type: NodeType.BUSINESS,
        position: { 
          x: business.position_x !== null && business.position_x !== undefined 
            ? Number(business.position_x) 
            : 50 + (index % 3) * 280, 
          y: business.position_y !== null && business.position_y !== undefined 
            ? Number(business.position_y) 
            : 50 + Math.floor(index / 3) * 200
        },
        data: {
          entity: business,
          label: business.name,
          size: { width: 256, height: 160 },
          business_id: business.id // ‰∫ãÊ•≠Ëá™Ë∫´„ÅÆID
        },
        // parentNodeÂâäÈô§: ‰∫ãÊ•≠„ÅØÁã¨Á´ã„Éé„Éº„Éâ
        draggable: true,
        selectable: true
      })
    })
    
    // Ê•≠Âãô„Éé„Éº„Éâ - ÂøÖ„Åö‰∫ãÊ•≠„Éé„Éº„ÉâÂÜÖ„Å´ÈÖçÁΩÆ
    tasks.forEach((task, index) => {
      if (!task.business_id) {
        console.error('Task without business_id found:', task.id, task.name)
        return // Ê•≠Âãô„ÅØÂøÖ„Åöbusiness_id„ÇíÊåÅ„Å§„Åπ„Åç
      }
      const parentId = `business-${task.business_id}`
      
      nodes.push({
        id: `task-${task.id}`,
        type: NodeType.TASK,
        position: { 
          x: task.position_x !== null && task.position_x !== undefined 
            ? Number(task.position_x) 
            : 50 + (index % 2) * 240, 
          y: task.position_y !== null && task.position_y !== undefined 
            ? Number(task.position_y) 
            : 250 + Math.floor(index / 2) * 120
        },
        data: {
          entity: task,
          label: task.name,
          size: { width: 224, height: 100 },
          business_id: task.business_id // business_idÁµ±ÂêàÂÆå‰∫Ü
        },
        // parentNode: parentId, // Ê•≠Âãô„Éé„Éº„Éâ„ÇíÁã¨Á´ã„Éé„Éº„Éâ„Å´Â§âÊõ¥
        // extent: 'parent' as const,
        draggable: true,
        selectable: true
      })
    })
    
    // ÂÆüË°åËÄÖ„Éé„Éº„Éâ - Ê•≠Âãô„Éé„Éº„ÉâÂÜÖ„Å´ÈÖçÁΩÆÔºàÊ•≠Âãô‚Üí‰∫ãÊ•≠„ÅÆÈöéÂ±§ÁµåÁî±Ôºâ
    executors.forEach((executor, index) => {
      if (!executor.task_id) {
        console.error('Executor without task_id found:', executor.id, executor.name)
        return // ÂÆüË°åËÄÖ„ÅØÂøÖ„Åötask_id„ÇíÊåÅ„Å§„Åπ„Åç
      }
      
      const task = tasks.find(t => t.id === executor.task_id)
      if (!task) {
        console.error('Executor references non-existent task:', executor.task_id)
        return
      }
      
      if (!task.business_id) {
        console.error('Executor task without business_id:', task.id, task.name)
        return
      }
      
      nodes.push({
        id: `executor-${executor.id}`,
        type: NodeType.EXECUTOR,
        position: { 
          x: executor.position_x !== null && executor.position_x !== undefined 
            ? Number(executor.position_x) 
            : 50 + (index % 3) * 200, 
          y: executor.position_y !== null && executor.position_y !== undefined 
            ? Number(executor.position_y) 
            : 400 + Math.floor(index / 3) * 100
        },
        data: {
          entity: executor,
          label: executor.name,
          size: { width: 192, height: 80 },
          business_id: task.business_id // ÊâÄÂ±ûÊ•≠Âãô„ÅÆ‰∫ãÊ•≠ID
        },
        // parentNode: `task-${executor.task_id}`, // ÂÆüË°åËÄÖ„Éé„Éº„Éâ„ÇíÁã¨Á´ã„Éé„Éº„Éâ„Å´Â§âÊõ¥
        // extent: 'parent' as const,
        draggable: true,
        selectable: true
      })
    })
    
    return nodes
  }
  
  // „Ç®„ÉÉ„Ç∏Â§âÊèõÔºà„Éá„Éº„Çø„Éô„Éº„Çπ„Åã„ÇâË™≠„ÅøËæº„Åø + Âõ∫ÂÆö„Ç®„ÉÉ„Ç∏Ôºâ
  static async convertToEdges(
    companies: Company[],
    positions: Position[],
    businesses: Business[],
    tasks: Task[],
    executors: Executor[],
    companyId: string
  ): Promise<Edge[]> {
    const edges: Edge[] = []
    
    try {
      // „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ‰øùÂ≠ò„Åï„Çå„Åü„Ç®„ÉÉ„Ç∏„ÇíË™≠„ÅøËæº„Åø
      const { data: savedEdges, error } = await supabase
        .from('edges')
        .select('*')
        .eq('company_id', companyId)

      if (error) {
        console.error('Failed to load edges from database:', error)
      } else if (savedEdges) {
        // ‰øùÂ≠ò„Åï„Çå„Åü„Ç®„ÉÉ„Ç∏„ÇíReact FlowÂΩ¢Âºè„Å´Â§âÊèõ
        savedEdges.forEach(edge => {
          edges.push({
            id: edge.id,
            source: edge.source_node_id,
            target: edge.target_node_id,
            type: edge.edge_type || 'default',
            style: edge.style || { 
              stroke: '#4c6ef5', 
              strokeWidth: 2,
              strokeDasharray: '2,4'
            },
            animated: edge.animated !== undefined ? edge.animated : true,
            reconnectable: edge.reconnectable !== undefined ? edge.reconnectable : true,
            deletable: edge.deletable !== undefined ? edge.deletable : true
          })
        })
        console.log('üìä LOADED EDGES FROM DATABASE:', savedEdges.length)
      }
    } catch (error) {
      console.error('Edge loading exception:', error)
    }

    // Âõ∫ÂÆö„Ç®„ÉÉ„Ç∏ÁîüÊàê„ÇíÂªÉÊ≠¢ÔºöÂÖ®„Å¶„ÅÆ„Ç®„ÉÉ„Ç∏„ÅØ„Éá„Éº„Çø„Éô„Éº„ÇπÁÆ°ÁêÜ„Å´Áµ±‰∏Ä
    console.log('üìä USING DATABASE EDGES ONLY - No static edge generation')
    
    return edges
  }
  
  // Áµ±ÂêàÂ§âÊèõ„É°„ÇΩ„ÉÉ„Éâ
  static async convertToFlowData(
    companies: Company[],
    positions: Position[],
    layers: Layer[],
    businesses: Business[],
    tasks: Task[],
    executors: Executor[],
    companyId: string,
    viewMode: 'company' | 'business' = 'company',
    selectedBusinessId?: string | null
  ): Promise<OrganizationFlowData> {
    let nodes = this.convertToNodes(companies, positions, layers, businesses, tasks, executors)
    let edges = await this.convertToEdges(companies, positions, businesses, tasks, executors, companyId)
    
    // ‰∫ãÊ•≠„Éì„É•„Éº„ÅÆÂ†¥Âêà„ÄÅ‰ºöÁ§æ„Å®CXOÈñ¢ÈÄ£„Éé„Éº„Éâ„ÇíÈô§Â§ñ
    if (viewMode === 'business') {
      nodes = nodes.filter(node => 
        node.type !== 'company' && 
        node.type !== 'cxo' && 
        node.type !== 'cxo_layer'
      )
      
      // ÁâπÂÆö„ÅÆ‰∫ãÊ•≠„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åù„ÅÆ‰∫ãÊ•≠Èñ¢ÈÄ£„ÅÆ„Éé„Éº„Éâ„ÅÆ„ÅøË°®Á§∫
      if (selectedBusinessId) {
        // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Çø„Çπ„ÇØID„ÇíÂèñÂæó
        const selectedBusinessTasks = tasks.filter(task => task.business_id === selectedBusinessId)
        const selectedBusinessTaskIds = selectedBusinessTasks.map(task => task.id)
        
        // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Ç®„ÇØ„Çº„Ç≠„É•„Éº„Çø„ÉºID„ÇíÂèñÂæó
        const selectedBusinessExecutors = executors.filter(executor => 
          selectedBusinessTaskIds.includes(executor.task_id)
        )
        const selectedBusinessExecutorIds = selectedBusinessExecutors.map(executor => executor.id)
        
        // „Ç®„ÉÉ„Ç∏„Åß„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇÇÂê´„ÇÅ„Å¶Ë°®Á§∫„Åô„Çã„Éé„Éº„Éâ„ÇíÊ±∫ÂÆö
        const connectedNodeIds = new Set<string>()
        
        // Âü∫Êú¨„ÅÆ‰∫ãÊ•≠Èñ¢ÈÄ£„Éé„Éº„Éâ„ÇíËøΩÂä†
        connectedNodeIds.add(`business-${selectedBusinessId}`)
        selectedBusinessTaskIds.forEach(taskId => connectedNodeIds.add(`task-${taskId}`))
        selectedBusinessExecutorIds.forEach(executorId => connectedNodeIds.add(`executor-${executorId}`))
        
        // „Ç®„ÉÉ„Ç∏„Åß„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†
        edges.forEach(edge => {
          const sourceNodeId = edge.source
          const targetNodeId = edge.target
          
          // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Éé„Éº„Éâ„Åã„ÇâÊé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†
          if (connectedNodeIds.has(sourceNodeId)) {
            connectedNodeIds.add(targetNodeId)
          }
          // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Éé„Éº„Éâ„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†  
          if (connectedNodeIds.has(targetNodeId)) {
            connectedNodeIds.add(sourceNodeId)
          }
        })
        
        // „É¨„Ç§„É§„Éº„Éé„Éº„Éâ„Å®„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíÂê´„ÇÅ„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        nodes = nodes.filter(node => {
          // ‰∫ãÊ•≠„É¨„Ç§„É§„Éº„ÅØÂ∏∏„Å´Ë°®Á§∫
          if (node.type === 'business_layer') return true
          
          // „Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíË°®Á§∫
          if (connectedNodeIds.has(node.id)) return true
          
          return false
        })
      }
      
      // ‰ºöÁ§æ„ÉªCXOÈñ¢ÈÄ£„ÅÆ„Ç®„ÉÉ„Ç∏„ÇÇÈô§Â§ñ
      edges = edges.filter(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source)
        const targetNode = nodes.find(n => n.id === edge.target)
        return sourceNode && targetNode
      })
    }
    
    return { nodes, edges }
  }

  // „Ç≥„É≥„ÉÜ„Éä„Éï„Ç£„É´„Çø„É™„É≥„Ç∞‰ªò„Åç„ÅÆÂ§âÊèõ„É°„ÇΩ„ÉÉ„Éâ
  static async convertToFlowDataWithContainerFilter(
    companies: Company[],
    positions: Position[],
    layers: Layer[],
    businesses: Business[],
    tasks: Task[],
    executors: Executor[],
    companyId: string,
    viewMode: 'company' | 'business' = 'company',
    selectedBusinessId?: string | null
  ): Promise<OrganizationFlowData> {
    let nodes = this.convertToNodes(companies, positions, layers, businesses, tasks, executors)
    let edges = await this.convertToEdges(companies, positions, businesses, tasks, executors, companyId)
    
    // ‰∫ãÊ•≠„Éì„É•„Éº„ÅÆÂ†¥Âêà„ÄÅ‰ºöÁ§æ„Å®CXOÈñ¢ÈÄ£„Éé„Éº„Éâ„ÇíÈô§Â§ñ
    if (viewMode === 'business') {
      nodes = nodes.filter(node => 
        node.type !== 'company' && 
        node.type !== 'cxo' && 
        node.type !== 'cxo_layer'
      )
      
      // ÁâπÂÆö„ÅÆ‰∫ãÊ•≠„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÄÅ„Åù„ÅÆ‰∫ãÊ•≠Èñ¢ÈÄ£„ÅÆ„Éé„Éº„Éâ„ÅÆ„ÅøË°®Á§∫
      if (selectedBusinessId) {
        // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Çø„Çπ„ÇØID„ÇíÂèñÂæó
        const selectedBusinessTasks = tasks.filter(task => task.business_id === selectedBusinessId)
        const selectedBusinessTaskIds = selectedBusinessTasks.map(task => task.id)
        
        // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Ç®„ÇØ„Çº„Ç≠„É•„Éº„Çø„ÉºID„ÇíÂèñÂæó
        const selectedBusinessExecutors = executors.filter(executor => 
          selectedBusinessTaskIds.includes(executor.task_id)
        )
        const selectedBusinessExecutorIds = selectedBusinessExecutors.map(executor => executor.id)
        
        // „Ç®„ÉÉ„Ç∏„Åß„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇÇÂê´„ÇÅ„Å¶Ë°®Á§∫„Åô„Çã„Éé„Éº„Éâ„ÇíÊ±∫ÂÆö
        const connectedNodeIds = new Set<string>()
        
        // Âü∫Êú¨„ÅÆ‰∫ãÊ•≠Èñ¢ÈÄ£„Éé„Éº„Éâ„ÇíËøΩÂä†
        connectedNodeIds.add(`business-${selectedBusinessId}`)
        selectedBusinessTaskIds.forEach(taskId => connectedNodeIds.add(`task-${taskId}`))
        selectedBusinessExecutorIds.forEach(executorId => connectedNodeIds.add(`executor-${executorId}`))
        
        // „Ç®„ÉÉ„Ç∏„Åß„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†
        edges.forEach(edge => {
          const sourceNodeId = edge.source
          const targetNodeId = edge.target
          
          // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Éé„Éº„Éâ„Åã„ÇâÊé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†
          if (connectedNodeIds.has(sourceNodeId)) {
            connectedNodeIds.add(targetNodeId)
          }
          // ÈÅ∏Êäû„Åï„Çå„Åü‰∫ãÊ•≠„ÅÆ„Éé„Éº„Éâ„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíËøΩÂä†  
          if (connectedNodeIds.has(targetNodeId)) {
            connectedNodeIds.add(sourceNodeId)
          }
        })
        
        // „É¨„Ç§„É§„Éº„Éé„Éº„Éâ„Å®„Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíÂê´„ÇÅ„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        nodes = nodes.filter(node => {
          // ‰∫ãÊ•≠„É¨„Ç§„É§„Éº„ÅØbusiness_id/attribute„Å´Âü∫„Å•„ÅÑ„Å¶„Éï„Ç£„É´„Çø„É™„É≥„Ç∞ÔºàÁµ±ÂêàÁâàÔºâ
          if (node.type === 'business_layer') {
            return this.shouldShowContainer({
              business_id: node.data.business_id
            }, selectedBusinessId)
          }
          
          // „Å§„Å™„Åå„Å£„Å¶„ÅÑ„Çã„Éé„Éº„Éâ„ÇíË°®Á§∫
          if (connectedNodeIds.has(node.id)) return true
          
          return false
        })
      }
      
      // ‰ºöÁ§æ„ÉªCXOÈñ¢ÈÄ£„ÅÆ„Ç®„ÉÉ„Ç∏„ÇÇÈô§Â§ñ
      edges = edges.filter(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source)
        const targetNode = nodes.find(n => n.id === edge.target)
        return sourceNode && targetNode
      })
    } else {
      // ‰ºöÁ§æ„Éì„É•„Éº„ÅÆÂ†¥Âêà„ÅØ„Ç≥„É≥„ÉÜ„Éä„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„ÅÆ„ÅøÈÅ©Áî®
      // attribute„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„É¨„Ç§„É§„Éº„ÅØ‰ºöÁ§æÂ±ûÊÄß„ÅßË°®Á§∫
      // ÔºàÊó¢Â≠ò„ÅÆÂãï‰Ωú„ÇíÁ∂≠ÊåÅÔºâ
    }
    
    return { nodes, edges }
  }
}